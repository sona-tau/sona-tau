<!DOCTYPE html>
<html lang="en-US" dir="ltr" id="html">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Diego's blog!">
<meta property="og:description" content="Diego's website for publishing projects, blogs and more!">
<meta property="og:image" content="https://diego-est.dev/banner.png">
<meta property="og:url" content="https://diego-est.dev">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Diego's blog!">
<meta name="twitter:description" content="Diego's website for publishing projects, blogs and more!">
<meta name="twitter:image" content="https://diego-est.dev/banner.png">
<meta name="twitter:site" content="@SunglYou">
<meta content="#43B581" data-react-helmet="true" name="theme-color" />
<title>Zig CTFP | My website!</title>


<style>
body {
    font-family: 'IBM Plex Mono';
}
 code {
     font-family: 'IBM Plex Mono'; 
 }
</style>

      <link rel="stylesheet" href="/css/main.min.15dcf4556255180784694b1561b1f2bbf9e58ada9c9ae2a91f8242fbbf8353c1.css" integrity="sha256-Fdz0VWJVGAeEaUsVYbHyu/nlitqcmuKpH4JC&#43;7&#43;DU8E=" crossorigin="anonymous">
        <link rel="stylesheet" href="/css/syntax.min.14e61992514fff6118d2aa5f5dacc3f9b109f0f8b2307d7910852fa23f81a4c2.css" />


      <script src="/js/main.da8a91f903d7f233623539233fe95de9b2d6901c04061a893b1d5ca12913141f.js" integrity="sha256-2oqR&#43;QPX8jNiNTkjP&#43;ld6bLWkBwEBhqJOx1coSkTFB8=" crossorigin="anonymous"></script>


</head>
<body>
<table class="header">
  <tr>
    <td colspan="2" rowspan="2" class="width-auto">
        <h1 class="title">Zig CTFP</h1>
        <span class="subtitle">Zig is a functional programming language</span>
    </td>
    <th>Version</th>
    <td class="width-min">1.0.0</td>
  </tr>
  <tr>
    <th>Updated</th>
    <td class="width-min"><time style="white-space: pre;">2024-08-07</time></td>
  </tr>
  <tr>
    <th class="width-min">Author</th><td class="width-auto"><a href="mailto:daestrada@pm.me"><cite>diego</cite></a></td>
    <th class="width-min">License</th>
    <td>MIT</td>
  </tr>
</table>
<label class="debug-toggle-label">
    <input type="checkbox" class="debug-toggle" />
    Debug mode
</label>
<label class="light-mode-toggle-label" id="light-mode-toggle-label">
    <input type="checkbox" class="light-mode-toggle" />
    Light mode
</label>
  <main>
    


  <p>Let this blog post be living proof that Zig is in fact also a functional
programming language.</p>
<h2 id="what">What?</h2>
<p>Well, there is a famous book called &ldquo;Category Theory For Programmers&rdquo; (in
short, CTFP) that expresses a lot of the core ideas of functional programming
through category theory. CTFP has a set of challenges at the end of each
chapter, and I aim to do all of them in Zig.</p>
<h2 id="challenges">Challenges</h2>
<h3 id="141">1.4.1</h3>
<blockquote>
<p>Implement, as best you can, the identity function in your favorite language
(or the second favorite, if your favorite language happens to be Haskell).</p>
</blockquote>
<p>For functional programming we will make heavy use of anonymous functions. So a
recurring pattern we will see is the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&lt;</span><span class="n">function</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">here</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}.</span><span class="n">call</span><span class="p">;</span><span class="w"> </span><span class="c1">// Notice this .call will make the expression return a function pointer.
</span></span></span></code></pre></div><h4 id="solution">Solution:</h4>
<p>So this challenge becomes very easy:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}.</span><span class="n">call</span><span class="p">;</span><span class="w"> </span><span class="c1">// The .call for id.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>PS.</p>
<p>Since we don&rsquo;t have function type inference in zig, we will make use of types as
values. So the function call looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="n">id</span><span class="p">(</span><span class="kt">i32</span><span class="p">)(</span><span class="mi">42</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>Some may be somewhat bothered by this syntax. But I think this is still fair
since C++&rsquo;s version of <code>id</code> without type inference (ie. using templates) is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">id</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="142">1.4.2</h3>
<blockquote>
<p>Implement the composition function in your favorite language. It takes two
functions as arguments and returns a function that is their composition.</p>
</blockquote>
<p>This is still very similar to the previous challenge but we do it twice nested.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="n">compose</span><span class="p">(</span><span class="n">A</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="o">:</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}.</span><span class="n">call</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}.</span><span class="n">call</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="solution-1">Solution:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">const</span><span class="w"> </span><span class="n">square_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)(</span><span class="n">square</span><span class="p">,</span><span class="w"> </span><span class="n">inc</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>You might notice that this only works for unary functions&hellip; Maybe in the future
I&rsquo;ll find a way to compose stuff in a better way. (maybe structs to pass multiple
parameters in a single parameter?)</p>
<h3 id="143">1.4.3</h3>
<blockquote>
<p>Write a program that tries to test that your composition function respects
identity.</p>
</blockquote>
<p>For this we need to verify that:</p>
<ol>
<li><code>f . id = f</code></li>
<li><code>id . f = f</code></li>
</ol>
<h4 id="solution-2">Solution:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">test</span><span class="w"> </span><span class="s">&#34;1.4.3&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">fid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)(</span><span class="n">inc</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="kt">i32</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">idf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compose</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)(</span><span class="n">id</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w"> </span><span class="n">inc</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expectEqual</span><span class="p">(</span><span class="n">fid</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expectEqual</span><span class="p">(</span><span class="n">idf</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="271">2.7.1</h3>
<blockquote>
<p>Define a higher-order function (or a function object) <code>memoize</code> in your
favorite language. This function takes a pure function <code>f</code> as an argument and
returns a function that behaves almost exactly like <code>f</code>, except that it only
calls the original function once for every argument, stores the result
internallly, and subsequently returns this stored result every time it&rsquo;s called
with the same argument. You can tell the memoize function from the original by
watching its preformance. For instance, try to memoize a function that takes a
long time to evaluate. You&rsquo;ll have to wait for the result the first time you
call it, but on sebsquent calls, with the same argument, you should get the
result immediately.</p>
</blockquote>
<p>This one&rsquo;s a doozy&hellip;
Basically we need to create a function that will memoize another function.
As elegantly expressed in <a href="https://matt.might.net/articles/closure-conversion/">Closure Conversion: How to compile lambda</a>
a closure is simply a lambda that can capture its environment. The way we
capture the environment is simply by adding more data fields to the struct!
So we simply add a <code>AutoHashMap</code> as a data field to the struct.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="n">memoize</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">A</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="kr">comptime</span><span class="w"> </span><span class="n">B</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kr">var</span><span class="w"> </span><span class="n">mp</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">HashMap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">hash_map</span><span class="p">.</span><span class="n">AutoContext</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"> </span><span class="mi">80</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">std</span><span class="p">.</span><span class="n">AutoHashMap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">).</span><span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">allocator</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kr">const</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="kr">const</span><span class="w"> </span><span class="n">new_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">mp</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">fn</span><span class="w"> </span><span class="n">deinit</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">mp</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">};</span><span class="w"> </span><span class="c1">// Notice there isn&#39;t a .call here. The caller must call this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">               </span><span class="c1">// closure with .call(args)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}.</span><span class="n">call</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="solution-3">Solution</h4>
<p>And it works!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="kr">const</span><span class="w"> </span><span class="n">memo_fib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memoize</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)(</span><span class="n">fib</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">defer</span><span class="w"> </span><span class="n">memo_fib</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expectEqual</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="n">memo_fib</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="272">2.7.2</h3>
<blockquote>
<p>Try to memoize a function from your standard library that you normally use to
produce random numbers. Does it work?</p>
</blockquote>
<p>Apparently, it does!
But this is only because it is being executed with the same seed, at
compiletime.</p>
<h4 id="solution-4">Solution:</h4>
<p>Since I haven&rsquo;t figured out how to pass functions with different arity, we must
create a wrapper for the standard library&rsquo;s rng. This function will get rid of
that argument since we don&rsquo;t need it to produce the random numbers.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zig" data-lang="zig"><span class="line"><span class="cl"><span class="k">fn</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="n">_</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">RndGen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">rand</span><span class="p">.</span><span class="n">DefaultPrng</span><span class="p">;</span><span class="w"> </span><span class="kr">var</span><span class="w"> </span><span class="n">rnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RndGen</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="nb">@bitCast</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">milliTimestamp</span><span class="p">())));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rnd</span><span class="p">.</span><span class="n">random</span><span class="p">().</span><span class="n">int</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Helper function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">const</span><span class="w"> </span><span class="n">RndGen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">rand</span><span class="p">.</span><span class="n">DefaultPrng</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">var</span><span class="w"> </span><span class="n">rnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RndGen</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="nb">@bitCast</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">milliTimestamp</span><span class="p">())));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kr">const</span><span class="w"> </span><span class="n">memo_rnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memoize</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)(</span><span class="n">rand</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">defer</span><span class="w"> </span><span class="n">memo_rnd</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expectEqual</span><span class="p">(</span><span class="n">rnd</span><span class="p">.</span><span class="n">random</span><span class="p">().</span><span class="n">int</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w"> </span><span class="n">memo_rnd</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></div><h2 id="la-fin">La Fin</h2>
<p>This is what I&rsquo;ve gotten up until now. Zig&rsquo;s syntax is ugly, and I&rsquo;m not
particularly excited about it&rsquo;s design philosophy but damn is it a solid
language. This little challenge has made me enjoy Zig a lot more than I thought.</p>
  


  </main>
  <footer>
    <p>Copyright 2025. All rights reserved.</p>

  </footer>
  <div class="debug-grid"></div>
  <script src="/js/main.js"></script>
</body>
</html>
